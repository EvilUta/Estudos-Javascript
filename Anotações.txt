üß© Vis√£o Geral de Estruturas de dados

Estruturas de dados s√£o formas organizadas de armazenar e manipular informa√ß√µes em um programa de forma eficiente.

Elas definem como os dados s√£o organizados, acessados, modificados e armazenados na mem√≥ria.

A estrutura define onde e como os dados ficam

O algoritmo define o que fazer com os dados

Um bom algoritmo precisa de uma estrutura adequada, e vice-versa.

| Estrutura      | Acesso | Inser√ß√£o | Remo√ß√£o | Ordem | Exemplo pr√°tico          |
| -------------- | ------ | -------- | ------- | ----- | ------------------------ |
| Array          | R√°pido | M√©dio    | M√©dio   | Sim   | Lista de produtos        |
| Lista ligada   | Lento  | R√°pido   | R√°pido  | Sim   | Editor de texto (ctrl+Z) |
| Pilha          | M√©dio  | R√°pido   | R√°pido  | Sim   | Hist√≥rico de navega√ß√£o   |
| Fila           | M√©dio  | R√°pido   | R√°pido  | Sim   | Fila de impress√£o        |
| √Årvore bin√°ria | M√©dio  | M√©dio    | M√©dio   | Sim   | Auto-complete, jogos     |
| Grafo          | Lento  | M√©dio    | M√©dio   | N√£o   | GPS, redes sociais       |
| Hash Table     | R√°pido | R√°pido   | R√°pido  | N√£o   | Dicion√°rio, cache        |

üéüÔ∏è FIFO ‚Äì First In, First Out (Primeiro a Entrar, Primeiro a Sair)
‚úÖ Defini√ß√£o:
FIFO √© uma regra de organiza√ß√£o de dados onde o primeiro elemento que entra √© o primeiro a sair.
üß† Como funciona:
Imagine uma fila de pessoas esperando para ser atendidas:

A primeira pessoa que chegou √© a primeira a ser atendida.
Os outros s√≥ ser√£o atendidos na ordem de chegada.

üöÄ Tipagem Fraca 
tipos de dados s√£o convertidos automaticamente quando necess√°rio, mesmo que isso possa causar comportamentos inesperados.

üîπ O que significa isso na pr√°tica?
Em linguagens de tipagem fraca, voc√™ pode fazer opera√ß√µes entre diferentes tipos de dados,
como string e n√∫mero, e a linguagem vai tentar converter automaticamente os valores para completar a opera√ß√£o.

üî∏ Exemplo em JavaScript (linguagem de tipagem fraca):
console.log("5" + 1); // Resultado: "51"
console.log("5" - 1); // Resultado: 4
console.log(true + 1); // Resultado: 2
console.log(null + 1); // Resultado: 1

Explica√ß√µes:

"5" + 1 ‚Üí o 1 vira string ‚Üí "5" + "1" ‚Üí "51"

"5" - 1 ‚Üí o "5" vira n√∫mero ‚Üí 5 - 1 ‚Üí 4

true + 1 ‚Üí true vira 1 ‚Üí 1 + 1 ‚Üí 2

null + 1 ‚Üí null vira 0 ‚Üí 0 + 1 ‚Üí 1

‚úÖ Vantagens:
C√≥digo mais flex√≠vel e menos verboso.

Pode acelerar a escrita de scripts simples.

‚ö†Ô∏è Desvantagens:
Pode causar bugs dif√≠ceis de perceber, pois a linguagem faz suposi√ß√µes autom√°ticas sobre os tipos.

Menor previsibilidade no comportamento do programa.

-------------------------------------------------------------------------------------------------------------------------------

‚ö° Number.isInteger(valor)
√© um m√©todo do objeto Number em JavaScript que verifica se um valor √© um n√∫mero inteiro.

üì¶ Exemplo: 
Number.isInteger(10);         // true
Number.isInteger(10.5);       // false
Number.isInteger("10");       // false (√© string, n√£o n√∫mero)
Number.isInteger(NaN);        // false
Number.isInteger(Infinity);   // false
Number.isInteger(0);          // true

üß† Observa√ß√µes:
Esse m√©todo n√£o converte o valor, ou seja, se passar uma string "10", o retorno ser√° false.

√â √∫til para validar entradas num√©ricas que precisam ser inteiras.

‚ö° toFixed(valor)
 um m√©todo em JavaScript usado para formatar n√∫meros com um n√∫mero fixo de casas decimais.

üì¶ Exemplo:
let num = 12.3456;

console.log(num.toFixed(2));  // "12.35"
console.log(num.toFixed(0));  // "12"
console.log(num.toFixed(4));  // "12.3456"
console.log(num.toFixed(6));  // "12.345600"

-> O numero que voc√™ colocar vai impimir as casas decimais 

‚ö° toString()
√© usado para converter um valor (geralmente um n√∫mero, booleano ou objeto) em uma string.

üì¶ Exemplo:
let numero = 123;
let texto = numero.toString();

console.log(texto);        // "123"
console.log(typeof texto); // string

‚ö° Math
 um objeto embutido que fornece propriedades e m√©todos para realizar opera√ß√µes matem√°ticas
 ‚Äî como arredondar, gerar n√∫meros aleat√≥rios, calcular pot√™ncias, ra√≠zes, etc.

üì¶ Exemplo:
let x = Math.sqrt(25);  // 5
let y = Math.pow(2, 3); // 8
let z = Math.random();  // n√∫mero aleat√≥rio entre 0 e 1

üîπ Principais m√©todos de Math:

| M√©todo               | O que faz                             | Exemplo                     |
| -------------------- | ------------------------------------- | --------------------------- |
| `Math.round(x)`      | Arredonda para o inteiro mais pr√≥ximo | `Math.round(4.7)` ‚Üí `5`     |
| `Math.floor(x)`      | Arredonda **para baixo**              | `Math.floor(4.7)` ‚Üí `4`     |
| `Math.ceil(x)`       | Arredonda **para cima**               | `Math.ceil(4.1)` ‚Üí `5`      |
| `Math.random()`      | Retorna n√∫mero entre `0` e `1`        | `Math.random()` ‚Üí `0.42`    |
| `Math.max(a, b,...)` | Maior n√∫mero                          | `Math.max(2, 5, 10)` ‚Üí `10` |
| `Math.min(a, b,...)` | Menor n√∫mero                          | `Math.min(2, 5, 10)` ‚Üí `2`  |
| `Math.sqrt(x)`       | Raiz quadrada                         | `Math.sqrt(9)` ‚Üí `3`        |
| `Math.pow(x, y)`     | Pot√™ncia                              | `Math.pow(2, 3)` ‚Üí `8`      |
| `Math.abs(x)`        | Valor absoluto (sem sinal)            | `Math.abs(-7)` ‚Üí `7`        |
| `Math.trunc(x)`      | Remove as casas decimais              | `Math.trunc(4.9)` ‚Üí `4`     |

-------------------------------------------------------------------------------------------------------------------------------
‚ö° string
 √© o tipo de dado usado para representar texto.
 Strings s√£o sequ√™ncias de caracteres e podem ser declaradas com aspas simples, aspas duplas ou crase (para template strings).

üì¶ Exemplo: 
let nome1 = "Renan";
let nome2 = 'Gustavo';
let nome3 = `Ol√°, ${nome1}`;  // template string (pode usar vari√°veis dentro)

üîπ Principais m√©todos de string:

| M√©todo                  | O que faz                                        | Exemplo                                           |
| ----------------------- | ------------------------------------------------ | ------------------------------------------------- |
| `length`                | Tamanho da string                                | `"Ol√°".length` ‚Üí `3`                              |
| `toUpperCase()`         | Tudo mai√∫sculo                                   | `"abc".toUpperCase()` ‚Üí `"ABC"`                   |
| `toLowerCase()`         | Tudo min√∫sculo                                   | `"ABC".toLowerCase()` ‚Üí `"abc"`                   |
| `charAt(i)`             | Retorna o caractere na posi√ß√£o `i`               | `"abc".charAt(1)` ‚Üí `"b"`                         |
| `indexOf("texto")`      | Posi√ß√£o onde come√ßa o texto (ou -1 se n√£o tiver) | `"banana".indexOf("na")` ‚Üí `2`                    |
| `includes("texto")`     | Retorna `true` se cont√©m                         | `"banana".includes("na")` ‚Üí `true`                |
| `replace("de", "para")` | Substitui texto                                  | `"dia bom".replace("bom", "ruim")` ‚Üí `"dia ruim"` |
| `slice(in√≠cio, fim)`    | Recorta parte da string                          | `"abcdef".slice(1, 4)` ‚Üí `"bcd"`                  |
| `split("separador")`    | Divide a string em array                         | `"a,b,c".split(",")` ‚Üí `["a", "b", "c"]`          |
| `trim()`                | Remove espa√ßos no in√≠cio e fim                   | `"  texto  ".trim()` ‚Üí `"texto"`                  |

‚ö° booleano
presentam verdadeiro ou falso, ou seja, t√™m apenas dois valores poss√≠veis:
true  // verdadeiro
false // falso

‚úÖ Exemplos b√°sicos:
let estaChovendo = true;
let temSol = false;

console.log(estaChovendo); // true
console.log(temSol);       // false

üîÅ Uso comum: em condi√ß√µes (if, while, etc.)
let idade = 18;
let maiorDeIdade = idade >= 18; // true

if (maiorDeIdade) {
  console.log("Voc√™ pode entrar!");
} else {
  console.log("Entrada proibida!");
}

‚ö° Array
Um array (ou vetor) √© uma estrutura de dados usada para armazenar v√°rios valores em uma √∫nica vari√°vel.
Em vez de declarar v√°rias vari√°veis, voc√™ pode usar um array para guardar uma lista de itens.

Os arrays em JavaScript s√£o din√¢micos (podem mudar de tamanho).
Os elementos s√£o indexados a partir do zero (0).
Podem armazenar valores de diferentes tipos (n√∫meros, strings, objetos, fun√ß√µes etc).

üì¶ Exemplo:
const frutas = ['ma√ß√£', 'banana', 'laranja'];
console.log(frutas[0]); // 'ma√ß√£'
console.log(frutas[1]); // 'banana'

üõ† M√©todos √∫teis:

| M√©todo       | O que faz                    |
| ------------ | ---------------------------- |
| `push()`     | Adiciona no final            |
| `pop()`      | Remove o √∫ltimo              |
| `shift()`    | Remove o primeiro            |
| `unshift()`  | Adiciona no come√ßo           |
| `length`     | Retorna o tamanho            |
| `indexOf()`  | Acha a posi√ß√£o de um item    |
| `includes()` | Verifica se cont√©m o item    |
| `slice()`    | Retorna uma parte do array   |
| `splice()`   | Adiciona ou remove elementos |

‚ö° Objeto 
Ele representa algo do mundo real com suas caracter√≠sticas (propriedades) e a√ß√µes (m√©todos).

üì¶ Exemplo b√°sico:
const pessoa = {
  nome: 'Renan',
  idade: 20,
  estudante: true
};

console.log(pessoa.nome);    // 'Renan'
console.log(pessoa['idade']); // 20

‚ö° Null e Undefined

üß™ Undefined
√â um valor autom√°tico dado a uma vari√°vel que foi declarada, mas n√£o recebeu valor ainda.

üì¶ Exemplo b√°sico:
let nome;
console.log(nome); // undefined

üß™ Null
√â um valor intencional que voc√™ mesmo define para indicar que n√£o h√° valor.

üì¶ Exemplo b√°sico:
let idade = null;
console.log(idade); // null

‚ö° Fun√ß√µes 
Voc√™ pode definir uma fun√ß√£o uma vez e usar (chamar) quantas vezes quiser.

üß± Estrutura b√°sica:
function nomeDaFuncao(par√¢metros) {
  // c√≥digo a ser executado
  return resultado;
}

‚úÖ Exemplo simples:
function somar(a, b) {
  return a + b;
}

console.log(somar(3, 4)); // 7

üß† Conceitos importantes:
| Termo      | O que √©                              |
| ---------- | ------------------------------------ |
| `function` | Palavra-chave para declarar a fun√ß√£o |
| Par√¢metros | Valores que a fun√ß√£o **recebe**      |
| `return`   | Valor que a fun√ß√£o **devolve**       |
| Chamada    | Quando voc√™ **executa** a fun√ß√£o     |

üß™ Fun√ß√£o sem retorno:
function mostrarMensagem() {
  console.log("Bem-vindo!");
}
mostrarMensagem(); // Apenas mostra algo, n√£o retorna

üß™ Fun√ß√£o com retorno: 
function soma (a, b = 0) {
    return a + b // retorna valor da soma
}

console.log(soma(30,40));

‚ö° Fun√ß√£o com arrow function (=>)
const soma = (a, b) => {
    return a + b;
}

üß© Arrow function com retorno impl√≠cito
const subtracao = (a, b) => a - b;


üîë Resumo das diferen√ßas:
| Forma                       | Exemplo                              | Usa `function` | Usa `=>` | `return` obrigat√≥rio? |
| --------------------------- | ------------------------------------ | -------------- | -------- | --------------------- |
| Fun√ß√£o an√¥nima tradicional  | `const f = function(a, b) { ... }`   | ‚úÖ              | ‚ùå        | ‚úÖ se quiser retorno   |
| Arrow function com bloco    | `const f = (a, b) => { return ... }` | ‚ùå              | ‚úÖ        | ‚úÖ                     |
| Arrow com retorno impl√≠cito | `const f = (a, b) => a + b`          | ‚ùå              | ‚úÖ        | ‚ùå (√© impl√≠cito)       |

‚ö° let
let √© uma palavra-chave usada para declarar vari√°veis em JavaScript, introduzida no ES6 (2015).

üìå Por que usar let?
Porque ela resolve problemas do var, como escopo e hoisting confusos.

‚úÖ 1. Escopo de bloco ({ })
Vari√°veis declaradas com let s√≥ existem dentro do bloco onde foram criadas.
{
  let nome = "Renan";
  console.log(nome); // Renan
}
console.log(nome); // ‚ùå Erro: nome is not defined

‚úÖ 2. Pode mudar de valor (reatribui√ß√£o)
let idade = 20;
idade = 21;
console.log(idade); // 21

‚úÖ 3. N√£o pode redeclarar no mesmo escopo
let cor = "azul";
// let cor = "vermelho"; // ‚ùå Erro: j√° foi declarada
cor = "vermelho"; // ‚úÖ S√≥ reatribuir

‚úÖ 4. Hoisting com let existe, mas n√£o √© utiliz√°vel antes da linha de declara√ß√£o
console.log(x); // ‚ùå Erro: Cannot access 'x' before initialization
let x = 5;

üß† Compara√ß√£o r√°pida:
| Caracter√≠stica  | `var`           | `let`                 |
| --------------- | --------------- | --------------------- |
| Escopo          | Fun√ß√£o          | **Bloco**             |
| Pode redeclarar | ‚úÖ              | ‚ùå                   |
| Pode reatribuir | ‚úÖ              | ‚úÖ                   |
| Hoisting        | Sim (acess√≠vel) | Sim (mas inacess√≠vel) |
| Introduzido em  | Muito antigo    | ES6 (2015)            |

‚ö° Loop
 s√£o usados para executar um bloco de c√≥digo v√°rias vezes.

üîÅ Tipos principais de loops:
1. for
2. while
3. do...while
4. for...of
5. for...in

üîπ 1. for (mais comum)
for (inicializa√ß√£o; condi√ß√£o; incremento) {
  // c√≥digo a ser repetido
}

‚úÖ Exemplo:
for (let i = 0; i < 5; i++) {
  console.log("Contador:", i);
}

Vai de 0 at√© 4.

üîπ 2. while (repete enquanto a condi√ß√£o for verdadeira)

‚úÖ Exemplo:
let i = 0;
while (i < 3) {
  console.log("i √©", i);
  i++;
}

Cuidado: se n√£o atualizar a vari√°vel, pode travar (loop infinito).

üîπ 3. do...while (executa ao menos uma vez)

‚úÖ Exemplo:
let i = 0;
do {
  console.log("Executado ao menos uma vez:", i);
  i++;
} while (i < 2);

üîπ 4. for...of (para arrays e strings)

‚úÖ Exemplo:
const nomes = ['Ana', 'Bruno', 'Carlos'];

for (let nome of nomes) {
  console.log(nome);
}

üîπ 5. for...in (para objetos)

‚úÖ Exemplo:
const pessoa = {
  nome: "Renan",
  idade: 20
};

for (let chave in pessoa) {
  console.log(chave, "->", pessoa[chave]);
}

üö´ Cuidado com loops infinitos:

‚úÖ Exemplo:
while (true) {
  // Nunca para! Use break ou condi√ß√µes bem definidas
}

üß† Dicas:
üîπ Use for quando souber quantas vezes quer repetir.
üîπ Use while quando n√£o souber ao certo, mas tiver uma condi√ß√£o.
üîπ Use for...of para arrays.
üîπ Use for...in para objetos.

‚ö° Hoisting 
move certas declara√ß√µes para o topo automaticamente, mesmo que voc√™ as escreva no meio ou no final do c√≥digo.

üß™ Exemplo cl√°ssico com var:
console.log(nome); // undefined
var nome = "Renan";

Por qu√™ isso funciona?
O JavaScript move a declara√ß√£o da vari√°vel nome para o topo assim:
var nome;         // ‚Üê hoisting
console.log(nome); // undefined
nome = "Renan";
üü° A vari√°vel foi criada, mas ainda n√£o atribu√≠da, por isso imprime undefined.

‚ùóCuidado: Hoisting n√£o move a atribui√ß√£o, s√≥ a declara√ß√£o.

‚úÖ Hoisting com function (fun√ß√µes declaradas):
dizerOi(); // "Oi!"

function dizerOi() {
  console.log("Oi!");
}
Isso funciona porque fun√ß√µes declaradas s√£o completamente i√ßadas (declara√ß√£o + corpo).

üî¥ Mas com let ou const, d√° erro!
console.log(nome); // ‚ùå ReferenceError
let nome = "Renan";

üß† Resumo:
| Tipo                                                      | Hoisting? | Valor antes da linha | Observa√ß√£o                       |
| --------------------------------------------------------- | --------- | -------------------- | -------------------------------- |
| `var`                                                     | ‚úÖ         | `undefined`           | S√≥ a **declara√ß√£o** √© i√ßada      |
| `let`                                                     | ‚úÖ         | ‚ùå Erro               | Fica na "zona morta" at√© a linha |
| `const`                                                   | ‚úÖ         | ‚ùå Erro               | Tamb√©m entra na "zona morta"     |
| `function`                                                | ‚úÖ         | ‚úÖ Funciona           | Declara√ß√£o e corpo s√£o i√ßados    |
| `function expression` ou `arrow function` com `const/let` | ‚ùå         | ‚ùå Erro               | N√£o funciona antes da linha      |

‚ö°  Par Nome/Valor
üîπ √â uma forma de representar dados onde voc√™ tem:
üîπ Um nome (chave) ‚Üí que identifica a informa√ß√£o
üîπ Um valor ‚Üí que √© a informa√ß√£o em si

üß± Sintaxe geral:
const pessoa = {
  nome: "Renan",
  idade: 20
};
Isso √© um objeto com dois pares nome/valor.

üìå Aplica√ß√µes comuns
üîπ 1. Em objetos:
const carro = {
  modelo: "Gol",
  ano: 2020,
  ligado: true
};
Aqui temos 3 pares nome/valor:
modelo ‚Üí "Gol"
ano ‚Üí 2020
ligado ‚Üí true

üìå 2. Em par√¢metros de fun√ß√£o:
function apresentar(nome, idade) {
  console.log("Nome:", nome);   // Par: nome ‚Üí valor passado
  console.log("Idade:", idade); // Par: idade ‚Üí valor passado
}

apresentar("Jo√£o", 30);
Os nomes dos par√¢metros viram chaves internas, e os argumentos s√£o os valores.

üìå 3. Em arrays de objetos:
const alunos = [
  { nome: "Ana", nota: 9 },
  { nome: "Pedro", nota: 7 }
];
Cada aluno √© um objeto com pares nome e nota.

üéØ Por que isso √© importante?
Porque:

Tudo em JavaScript √© baseado em objetos.
A comunica√ß√£o entre dados (por exemplo, com APIs) √© feita via pares nome/valor em JSON.

üì¶ JSON √© s√≥ Par Nome/Valor
{
  "produto": "Camisa",
  "preco": 49.9,
  "disponivel": true
}

üß† Em resumo:
üîπ Nome = identificador
üîπ Valor = dado associado
üîπ Esse conceito √© a base da estrutura de objetos em JavaScript (e JSON)

‚ö°  Destructuring
Destructuring √© uma forma de extrair valores de arrays ou objetos e atribu√≠-los a vari√°veis de forma r√°pida e clara.

üß± Exemplo b√°sico:
const pessoa = {
  nome: "Renan",
  idade: 20,
  cidade: "S√£o Paulo"
};

// Extraindo com destructuring:
const { nome, idade } = pessoa;

console.log(nome);  // "Renan"
console.log(idade); // 20

üìå Explica√ß√£o:
const { nome, idade } = pessoa pega os valores das chaves nome e idade do objeto pessoa e os atribui a vari√°veis com o mesmo nome.

üß© Tamb√©m d√° pra renomear:
const { nome: n, idade: i } = pessoa;

console.log(n); // "Renan"
console.log(i); // 20

üì¶ 2. Destructuring com arrays
const numeros = [10, 20, 30];

const [a, b] = numeros;

console.log(a); // 10
console.log(b); // 20

üìå Importante:
A ordem importa! O a recebe o primeiro valor (10), o b o segundo (20).

‚ûï Pular elementos:
const [primeiro, , terceiro] = [1, 2, 3];
console.log(primeiro); // 1
console.log(terceiro); // 3

üéØ Usos comuns:
‚úÖ Em par√¢metros de fun√ß√£o:
function exibir({ nome, idade }) {
  console.log(`${nome} tem ${idade} anos`);
}

exibir({ nome: "Jo√£o", idade: 25 });

‚úÖ Em fun√ß√µes com array:
function somar([a, b]) {
  return a + b;
}

console.log(somar([2, 3])); // 5

‚úÖ Com valores padr√£o:
const { nome = "Desconhecido", idade = 0 } = {};
console.log(nome); // "Desconhecido"

üß† Resumo:
| Tipo   | Exemplo                          | Extra√ß√£o                   |
| ------ | -------------------------------- | -------------------------- |
| Objeto | `{ nome, idade } = pessoa`       | Por chave                  |
| Array  | `[a, b] = numeros`               | Por posi√ß√£o                |
| Fun√ß√£o | `function({nome})` ou `([a, b])` | Diretamente nos par√¢metros |


‚ö° Aritm√©ticos
Operadores aritm√©ticos s√£o usados para realizar opera√ß√µes matem√°ticas com valores num√©ricos.

üßÆ Principais operadores:
| Operador | Nome           | Exemplo        | Resultado   |
| -------- | -------------- | -------------- | ----------- |
| `+`      | Adi√ß√£o         | `5 + 3`        | `8`         |
| `-`      | Subtra√ß√£o      | `5 - 3`        | `2`         |
| `*`      | Multiplica√ß√£o  | `5 * 3`        | `15`        |
| `/`      | Divis√£o        | `6 / 2`        | `3`         |
| `%`      | M√≥dulo (resto) | `7 % 2`        | `1`         |
| `**`     | Exponencia√ß√£o  | `2 ** 3`       | `8`         |
| `++`     | Incremento     | `x++` ou `++x` | `x = x + 1` |
| `--`     | Decremento     | `x--` ou `--x` | `x = x - 1` |

üìå Exemplos pr√°ticos:
let a = 10;
let b = 3;

console.log(a + b);  // 13
console.log(a - b);  // 7
console.log(a * b);  // 30
console.log(a / b);  // 3.333...
console.log(a % b);  // 1
console.log(a ** b); // 1000

// Incremento e decremento
let x = 5;
console.log(x++); // 5 (primeiro mostra, depois incrementa)
console.log(x);   // 6
console.log(++x); // 7 (incrementa antes de mostrar)

‚ö†Ô∏è Aten√ß√£o:
Opera√ß√µes com tipos n√£o num√©ricos podem resultar em NaN (Not a Number):
console.log("abc" * 2); // NaN

A divis√£o por zero em JavaScript n√£o d√° erro, mas resulta em Infinity:
console.log(10 / 0); // Infinity

‚ö° Operadores Relacionais
Operadores relacionais comparam valores e retornam um resultado booleano: true ou false.

üìò Principais operadores:
| Operador | Significado                           | Exemplo     | Resultado |
| -------- | ------------------------------------- | ----------- | --------- |
| `>`      | Maior que                             | `5 > 3`     | `true`    |
| `<`      | Menor que                             | `5 < 3`     | `false`   |
| `>=`     | Maior ou igual                        | `5 >= 5`    | `true`    |
| `<=`     | Menor ou igual                        | `3 <= 2`    | `false`   |
| `==`     | Igual (valor)                         | `5 == "5"`  | `true`    |
| `!=`     | Diferente (valor)                     | `5 != "5"`  | `false`   |
| `===`    | Estritamente igual (valor e tipo)     | `5 === "5"` | `false`   |
| `!==`    | Estritamente diferente (valor e tipo) | `5 !== "5"` | `true`    |

üß™ Exemplos pr√°ticos:
console.log(10 > 5);    // true
console.log(10 < 5);    // false
console.log(10 >= 10);  // true
console.log(10 <= 9);   // false

// Compara√ß√µes com == e ===
console.log(5 == '5');   // true (s√≥ compara o valor)
console.log(5 === '5');  // false (valor igual, mas tipos diferentes)

// Compara√ß√µes com != e !==
console.log(5 != '5');   // false
console.log(5 !== '5');  // true

‚ö†Ô∏è Dica importante:
Sempre que poss√≠vel, prefira usar === e !== no lugar de == e !=, pois evita erros de tipo impl√≠cito.

‚ö° Operadores L√≥gicos 
Operadores l√≥gicos servem para combinar ou inverter express√µes booleanas
usados principalmente em estruturas de decis√£o (if, while, etc).

‚úÖ Principais operadores:
| Operador | Nome          | Exemplo         | Resultado                                 |        |   |         |                                  |
| -------- | ------------- | --------------- | ----------------------------------------- | ------ | - | ------- | -------------------------------- |
| `&&`     | **E** (AND)   | `true && false` | `false` (os dois t√™m que ser verdadeiros) |        |   |         |                                  |
| \`       |               | \`              | **OU** (OR)                               | \`true |   | false\` | `true` (basta um ser verdadeiro) |
| `!`      | **N√ÉO** (NOT) | `!true`         | `false` (inverte o valor)                 |        |   |         |                                  |

üß™ Exemplos pr√°ticos:
// AND - s√≥ retorna true se os dois forem true
console.log(true && true);   // true
console.log(true && false);  // false

// OR - retorna true se pelo menos um for true
console.log(false || true);  // true
console.log(false || false); // false

// NOT - inverte o valor
console.log(!true);  // false
console.log(!false); // true

üß† Curiosidades:
1. Avalia√ß√£o de curto-circuito:
JavaScript avalia da esquerda pra direita, e pode parar cedo se j√° souber o resultado:
false && qualquerCoisa(); // "qualquerCoisa()" nem √© executada
true || qualquerCoisa();  // idem

2. && e || n√£o retornam apenas true ou false:
Eles retornam o valor mesmo, se n√£o forem booleanos:
console.log(0 || 'Texto');      // 'Texto' (0 √© falsy)
console.log('Oi' && 123);       // 123 ('Oi' √© truthy, continua)
console.log(null || 'padr√£o');  // 'padr√£o'

‚ö†Ô∏è Valores "falsy" no JavaScript:
Esses s√£o tratados como false em contextos booleanos:

false

0

'' (string vazia)

null

undefined

NaN

Tudo o resto √© truthy (inclusive [], {}, "0", etc.).

‚ö° Un√°rios
Operadores un√°rios s√£o aqueles que atuam sobre apenas um operando. Eles modificam ou retornam um valor com base em uma √∫nica vari√°vel.

üß† Principais Operadores Un√°rios
| Operador | Nome                    | Exemplo                      | Explica√ß√£o                                                        |
| -------- | ----------------------- | ---------------------------- | ----------------------------------------------------------------- |
| `!`      | L√≥gico de nega√ß√£o (NOT) | `!true` ‚Üí `false`            | Inverte o valor booleano.                                         |
| `typeof` | Tipo de dado            | `typeof "abc"` ‚Üí `"string"`  | Retorna o tipo da vari√°vel.                                       |
| `delete` | Remover propriedade     | `delete obj.nome`            | Remove uma propriedade de um objeto.                              |
| `++`     | Incremento              | `x++` ou `++x`               | Soma 1 ao valor. Pr√© ou p√≥s-incremento.                           |
| `--`     | Decremento              | `x--` ou `--x`               | Subtrai 1 do valor. Pr√© ou p√≥s-decremento.                        |
| `+`      | Convers√£o para n√∫mero   | `+"123"` ‚Üí `123`             | Converte string para n√∫mero.                                      |
| `-`      | Nega√ß√£o num√©rica        | `-5` ‚Üí `-5`, `-"10"` ‚Üí `-10` | Inverte o sinal do n√∫mero (ou converte string num√©rica negativa). |
| `void`   | Retorna `undefined`     | `void 0`                     | Avalia uma express√£o e retorna `undefined`. Pouco usado.          |

üéØ Exemplos Pr√°ticos
let a = true;
console.log(!a); // false

let x = "10";
console.log(+x); // 10 ‚Üí converte para n√∫mero

let obj = { nome: "Renan", idade: 20 };
delete obj.nome;
console.log(obj); // { idade: 20 }

let n = 5;
console.log(++n); // 6 (pr√©-incremento)
console.log(n--); // 6 (p√≥s-decremento, mas depois vira 5)

‚ö°Tern√°rio
O operador tern√°rio √© uma forma curta e pr√°tica de escrever condicionais do tipo if/else.
Ele tem tr√™s partes, por isso o nome tern√°rio.

üß† Sintaxe:
condi√ß√£o ? valor_se_verdadeiro : valor_se_falso;

üìå Exemplos:
const idade = 18;
const podeBeber = idade >= 18 ? "Sim" : "N√£o";
console.log(podeBeber); // "Sim"

const nota = 7.5;
const resultado = nota >= 7 ? "Aprovado" : "Reprovado";
console.log(resultado); // "Aprovado"

üéØ Com tern√°rio aninhado (n√£o recomendado para c√≥digos longos):
const nota = 9;
const conceito = nota >= 9 ? "A" : nota >= 7 ? "B" : "C";
console.log(conceito); // "A"

‚ö†Ô∏è Dica:
Use o tern√°rio para condi√ß√µes simples. Para l√≥gica mais complexa ou v√°rias condi√ß√µes, use if/else para deixar o c√≥digo mais leg√≠vel.

‚ö° Switch
O switch √© uma estrutura de controle de fluxo em JavaScript (e em v√°rias outras linguagens)
Usada para escolher entre m√∫ltiplos caminhos com base no valor de uma vari√°vel ou express√£o.

‚úÖ Sintaxe b√°sica:
switch (expressao) {
    case valor1:
        // bloco de c√≥digo se expressao === valor1
        break
    case valor2:
        // bloco de c√≥digo se expressao === valor2
        break
    default:
        // bloco de c√≥digo se nenhum dos cases for correspondente
}

üìå Explicando:
expressao: √© avaliada uma vez.

üîπ case valorX: compara o resultado da express√£o com valorX usando ===.

üîπ break: impede que o c√≥digo continue executando os outros cases (isso se chama "fall through").

üîπ default: executa se nenhum case for correspondente (opcional, mas recomendado).

üìò Exemplo pr√°tico:
let nota = 8

switch (Math.floor(nota)) {
    case 10:
    case 9:
        console.log("Quadro de Honra")
        break
    case 8:
    case 7:
        console.log("Aprovado")
        break
    case 6:
    case 5:
    case 4:
        console.log("Recupera√ß√£o")
        break
    default:
        console.log("Reprovado")
}

Resultado:
Se nota = 8, o resultado ser√°: Aprovado

‚ö†Ô∏è Sem o break:
Sem o break, ele continua executando os pr√≥ximos blocos, mesmo que o case correto j√° tenha sido encontrado.

let cor = 'azul'

switch (cor) {
    case 'azul':
        console.log('Voc√™ escolheu azul')
    case 'vermelho':
        console.log('Voc√™ escolheu vermelho')
}

Resultado
Voc√™ escolheu azul  
Voc√™ escolheu vermelho  ‚Üê (isso aconteceu por falta do `break`)

‚ö° while
O while √© uma estrutura de repeti√ß√£o (loop) no JavaScript que executa um bloco de c√≥digo repetidamente enquanto uma condi√ß√£o for verdadeira.

‚úÖ Sintaxe
while (condi√ß√£o) {
    // c√≥digo a ser executado enquanto a condi√ß√£o for true
}

üìò Exemplo simples:
let contador = 1

while (contador <= 5) {
    console.log("Contando: " + contador)
    contador++  // aumenta o contador em 1 a cada volta
}

Resultado:
Contando: 1
Contando: 2
Contando: 3
Contando: 4
Contando: 5

‚ö†Ô∏è Cuidado com loops infinitos
Se voc√™ esquecer de atualizar a vari√°vel que muda a condi√ß√£o, o while nunca para e trava o programa:
let i = 1
while (i <= 5) {
    console.log(i)
    // falta o i++ aqui
}

üîÑ Compara√ß√£o com for
Esse while:

let i = 0
while (i < 3) {
    console.log(i)
    i++
}

√â equivalente a esse for:

for (let i = 0; i < 3; i++) {
    console.log(i)
}

üìå Exemplo pr√°tico:

let senha = ""

while (senha !== "1234") {
    senha = prompt("Digite a senha correta:")
}

alert("Acesso liberado!")

‚ö†Ô∏è Esse exemplo s√≥ funciona no navegador, pois usa prompt.

‚ö° O do while √© uma estrutura de repeti√ß√£o muito parecida com o while, mas com uma diferen√ßa importante:

Ele executa o bloco de c√≥digo primeiro, e s√≥ depois testa a condi√ß√£o.

‚úÖ Sintaxe:
do {
    // c√≥digo a ser executado
} while (condi√ß√£o)

üìå Diferen√ßa entre while e do...while:
| Tipo         | Verifica a condi√ß√£o antes? | Garante ao menos uma execu√ß√£o? |
| ------------ | -------------------------- | ------------------------------ |
| `while`      | Sim                        | N√£o                            |
| `do...while` | N√£o (executa antes)        | Sim                            |

üìò Exemplo pr√°tico:
let senha

do {
    senha = prompt("Digite a senha:")
} while (senha !== "1234")

alert("Acesso permitido")

Mesmo que a senha j√° esteja correta, o do...while roda pelo menos uma vez.

üîÑ Exemplo simples com n√∫mero:
let numero = 0

do {
    console.log("N√∫mero: " + numero)
    numero++
} while (numero < 3)

Resultado:
N√∫mero: 0
N√∫mero: 1
N√∫mero: 2

üß† Resumo:
while: testa antes, pode n√£o executar nenhuma vez.

do...while: executa primeiro, testa depois.

‚ö° For
Estrutura de repeti√ß√£o

üîÅ 1. Contando de 1 a 10
for (let i = 1; i <= 10; i++) {
  console.log(i);
}

‚ö° For / IN
√â um tipo espec√≠fico de la√ßo para iterar sobre as chaves (nomes de propriedades) de um objeto.

A estrutura b√°sica √©:
for (let chave in objeto) {
    console.log(chave);         // nome da propriedade
    console.log(objeto[chave]); // valor da propriedade
}

Exemplo com objeto:
const pessoa = {
    nome: "Renan",
    idade: 20,
    cidade: "S√£o Paulo"
};

for (let prop in pessoa) {
    console.log(`${prop}: ${pessoa[prop]}`);
}

Sa√≠da:
nome: Renan
idade: 20
cidade: S√£o Paulo


üìå Diferente do for...of

for...in ‚Üí percorre √≠ndices ou nomes de propriedades.

for...of ‚Üí percorre valores diretamente (funciona com arrays, strings, etc.).


üß† Exemplo com array:
const frutas = ["ma√ß√£", "banana", "uva"];

for (let i in frutas) { // i = √≠ndice
    console.log(i, frutas[i]);
}

for (let fruta of frutas) { // fruta = valor
    console.log(fruta);
}

‚ö° 'Break / continue'
break e continue s√£o usados dentro de la√ßos (for, while, do...while) para controlar o fluxo de execu√ß√£o, mas eles fazem coisas bem diferentes:

1. break ‚Äî sai completamente do la√ßo
Quando o JavaScript encontra break, ele para o loop na hora e pula para a pr√≥xima instru√ß√£o depois dele.
for (let i = 1; i <= 5; i++) {
    if (i === 3) {
        break; // Sai do la√ßo quando i for 3
    }
    console.log(i);
}

console.log("Fim");

Sa√≠da:
1
2
Fim
O 3 e os n√∫meros seguintes n√£o s√£o executados porque o loop foi interrompido.

2. continue ‚Äî pula para a pr√≥xima repeti√ß√£o
O continue n√£o sai do la√ßo, mas pula o resto do c√≥digo naquela itera√ß√£o e vai direto para a pr√≥xima.
for (let i = 1; i <= 5; i++) {
    if (i === 3) {
        continue; // Pula o resto quando i for 3
    }
    console.log(i);
}

console.log("Fim");

Sa√≠da:
1
2
4
5
Fim
Aqui o 3 foi "ignorado", mas o loop continuou normalmente.

üìå Resumo r√°pido:

break ‚Üí sai do loop completamente.

continue ‚Üí pula apenas aquela volta e segue para a pr√≥xima.

    ‚ö°‚ö° Fun√ß√£o ‚ö°‚ö°

Fun√ß√µes em JavaScript s√£o blocos de c√≥digo reutiliz√°veis que executam uma tarefa espec√≠fica. Elas podem:

üìå Ser declaradas de forma tradicional:
function soma(a, b) { return a + b }
 
üìå Ser atribu√≠das a vari√°veis (fun√ß√µes an√¥nimas):
const soma = function(a, b) { return a + b }

üìå Usar arrow functions para sintaxe mais curta:
const soma = (a, b) => a + b

üîπ Ser passadas como argumento para outras fun√ß√µes ou retornadas por elas (fun√ß√µes de primeira classe e de ordem superior).

üîπ Ser armazenadas em arrays, objetos, ou vari√°veis.

üîπ Podem ter par√¢metros (entradas) e valores de retorno (sa√≠das) usando return.

üîπ Se nenhum valor for retornado, a fun√ß√£o retorna undefined.

‚ö° This e Bind 

1Ô∏è‚É£ O que √© this
O this √© uma refer√™ncia que aponta para quem est√° chamando a fun√ß√£o no momento da execu√ß√£o.
O valor de this n√£o √© fixo ‚Äî ele depende de como a fun√ß√£o foi chamada.

Exemplos:
const pessoa = {
    nome: "Renan",
    falar() {
        console.log(this.nome);
    }
};

pessoa.falar(); // "Renan" ‚Üí this = pessoa

üîπ Se voc√™ tirar a fun√ß√£o do objeto:
const falarFora = pessoa.falar;
falarFora(); // undefined ‚Üí this n√£o aponta mais para "pessoa"

-> Aqui o this perde o contexto e vira undefined (modo estrito) ou window (modo solto no navegador).

2Ô∏è‚É£ Como fixar o this com bind
O .bind() cria uma nova fun√ß√£o onde o this sempre vai apontar para o objeto que voc√™ escolher.
const falarFixo = pessoa.falar.bind(pessoa);
falarFixo(); // "Renan" ‚Üí this sempre ser√° pessoa

3Ô∏è‚É£ Diferen√ßa entre bind, call e apply
bind(obj) ‚Üí devolve uma nova fun√ß√£o com o this preso no obj.

call(obj, arg1, arg2, ...) ‚Üí executa a fun√ß√£o imediatamente com o this definido.

apply(obj, [args]) ‚Üí igual ao call, mas argumentos em array.

exemplo:
function mostrar(a, b) {
    console.log(this.nome, a, b);
}

const pessoa2 = { nome: "Jo√£o" };

mostrar.call(pessoa2, 1, 2);  // Jo√£o 1 2
mostrar.apply(pessoa2, [1, 2]); // Jo√£o 1 2
const nova = mostrar.bind(pessoa2);
nova(1, 2); // Jo√£o 1 2

üí° Resumo da l√≥gica do this:

üîπ Quem chama ‚Üí define o this.

üîπ Se perder o objeto que chamou ‚Üí perde o this.

üîπ Use bind para prender o this permanentemente.

‚ö° Arrow
1Ô∏è‚É£ Sintaxe b√°sica
Uma arrow function √© uma forma mais curta de escrever fun√ß√µes:
// Fun√ß√£o normal
function soma(a, b) {
    return a + b;
}

// Arrow function
const soma2 = (a, b) => a + b;

üîπ Se tiver uma √∫nica express√£o, o return √© impl√≠cito.

üîπ Se tiver mais de uma linha, usa chaves {} e precisa do return expl√≠cito:
const soma3 = (a, b) => {
    const resultado = a + b;
    return resultado;
}

üîπ Para um √∫nico par√¢metro, pode omitir os par√™nteses:
const quadrado = x => x * x;

2Ô∏è‚É£ Diferen√ßa principal: o this
üîπ A maior diferen√ßa da arrow function √© que ela n√£o cria seu pr√≥prio this.

üîπ Ela herda o this do contexto onde foi definida.

üîπ Isso √© √≥timo para callbacks, timers, eventos, etc.
Exemplo com setInterval:
function Pessoa() {
    this.idade = 0;

    // Arrow function mant√©m o 'this' da fun√ß√£o Pessoa
    setInterval(() => {
        this.idade++;
        console.log(this.idade);
    }, 1000);
}

new Pessoa();
Aqui, this.idade funciona corretamente, porque a arrow function n√£o muda o this, diferente de uma fun√ß√£o normal.

3Ô∏è‚É£ Outras caracter√≠sticas
Arrow functions n√£o podem ser usadas como construtoras (new ArrowFunction() d√° erro).

Elas n√£o t√™m arguments, ent√£o para acessar os argumentos usa ...rest:
const soma = (...nums) => nums.reduce((a, b) => a + b);

üí° Resumo pr√°tico:

üîπ Sintaxe curta.

üîπ this herda do contexto, n√£o cria novo.

üîπ Bom para fun√ß√µes curtas, callbacks, timers e eventos.

‚ö° Fun√ß√µes an√¥nimas ou Fun√ß√£o sem nome
Elas normalmente s√£o usadas quando voc√™ precisa criar uma fun√ß√£o r√°pida, que ser√° passada como argumento ou atribu√≠da a uma vari√°vel,
mas n√£o precisa ser reutilizada pelo nome.

üìå Sintaxe b√°sica
// Fun√ß√£o an√¥nima atribu√≠da a uma vari√°vel
const soma = function(a, b) {
    return a + b;
};

console.log(soma(3, 4)); // 7

üìå Caracter√≠sticas principais

üîπ Sem identificador ‚Üí n√£o possuem nome pr√≥prio.

üîπ Normalmente atribu√≠das a vari√°veis, constantes ou propriedades de objetos.

üîπ Muito usadas como callbacks (fun√ß√µes passadas para outras fun√ß√µes).

üîπ Podem ser fun√ß√µes tradicionais ou arrow functions.

üìå Exemplos comuns
1. Callback em setTimeout
setTimeout(function() {
    console.log("Executou ap√≥s 2 segundos");
}, 2000);

2. Fun√ß√£o em um evento
document.querySelector("#btn").addEventListener("click", function() {
    alert("Bot√£o clicado!");
});

3. Arrow Function (forma mais curta)
const dobro = (n) => n * 2;
console.log(dobro(5)); // 10

üí° Quando usar?

üîπ Quando a fun√ß√£o √© simples e n√£o ser√° reutilizada em outro lugar.

üîπ Quando est√° servindo de par√¢metro para outra fun√ß√£o (callback).

üîπ Quando voc√™ quer escrever menos c√≥digo e evitar declarar nomes desnecess√°rios.

‚ö° Callback
Uma fun√ß√£o callback √© simplesmente uma fun√ß√£o passada como argumento para outra fun√ß√£o
executada depois que a fun√ß√£o ‚Äúprincipal‚Äù terminar seu trabalho ou atingir certo ponto

Exemplo simples
function cumprimentar(nome, callback) {
    console.log("Ol√°, " + nome + "!");
    callback(); // Chama a fun√ß√£o recebida
}

function despedir() {
    console.log("At√© logo!");
}

cumprimentar("Renan", despedir);

Sa√≠da:
Ol√°, Renan!
At√© logo!

Aqui:

despedir √© a fun√ß√£o callback.

Ela foi passada para cumprimentar e s√≥ executa quando callback() √© chamado dentro dela.

‚ö° Factory e classe

1Ô∏è‚É£ 1. Factory Function (Fun√ß√£o F√°brica)
√â simplesmente uma fun√ß√£o que cria e retorna objetos.
Ela √© chamada de f√°brica porque ‚Äúfabrica‚Äù objetos, muitas vezes sem usar new.
Exemplo:
function criarProduto(nome, preco) {
    return {
        nome,
        preco,
        aplicarDesconto(desconto) {
            return this.preco * (1 - desconto);
        }
    };
}

const notebook = criarProduto("Notebook", 3999);
console.log(notebook.aplicarDesconto(0.10)); // 3599.1

‚û°Ô∏è Aqui, cada vez que voc√™ chama criarProduto(...), ele retorna um novo objeto.
üîπ Vantagem: simples, flex√≠vel, n√£o precisa de new.
üîπ Desvantagem: se criar muitos objetos, pode duplicar fun√ß√µes na mem√≥ria (embora hoje em dia isso n√£o seja um grande problema).

2Ô∏è‚É£ 2. Classe (Class)
√â a forma mais pr√≥xima da orienta√ß√£o a objetos tradicional (como em Java, C#, etc.).
Uma class √© como um molde para criar objetos com new.

Exemplo:
class Produto {
    constructor(nome, preco) {
        this.nome = nome;
        this.preco = preco;
    }

    aplicarDesconto(desconto) {
        return this.preco * (1 - desconto);
    }
}

const celular = new Produto("Celular", 2500);
console.log(celular.aplicarDesconto(0.20)); // 2000

‚û°Ô∏è Aqui voc√™ define a estrutura (nome, preco) e os m√©todos (aplicarDesconto) dentro da classe.
üîπ Vantagem: m√©todos ficam no prototype (mais eficiente em mem√≥ria).
 Vantagem: m√©todos ficam no prototype (mais eficiente em mem√≥ria).
üîπ Desvantagem: sintaxe um pouco mais verbosa.

üîë Diferen√ßa resumida:
üîπ Factory: fun√ß√£o que retorna um objeto pronto.
üîπ Classe: um molde que voc√™ instancia com new.
üîπ Factory √© mais flex√≠vel para criar objetos diferentes rapidamente.
üîπ Classe √© melhor quando voc√™ quer uma estrutura clara e reaproveitar m√©todos sem duplicar.

‚ö° IIFE
Declarada e executada imediatamente ap√≥s sua cria√ß√£o
O principal objetivo √© criar um escopo isolado, sem poluir o escopo global.

‚û°Ô∏è A sintaxe b√°sica √©:
(function() {
    console.log("Executando imediatamente!");
})();
'
‚û°Ô∏è Ou usando arrow function:
(() => {
    console.log("Executando imediatamente com arrow function!");
})();

Como funciona:
üîπ A fun√ß√£o √© envolvida por par√™nteses (function(){ ... }) para transform√°-la em uma express√£o.
üîπ O () no final executa a fun√ß√£o imediatamente.
üîπ Tudo que estiver dentro dela fica isolado do escopo global.

‚û°Ô∏è Exemplo √∫til:
let contador = 0;

(function() {
    let contador = 10; // escopo isolado
    console.log(contador); // 10
})();

console.log(contador); // 0, o contador global n√£o foi alterado

‚ö° CALL e APPLY 
Executar uma fun√ß√£o definindo explicitamente o valor de this dentro dela
Eles s√£o muito parecidos, mas a diferen√ßa est√° na forma como voc√™ passa os argumentos.

1. call
Sintaxe:
func.call(thisValor, arg1, arg2, ...);
üîπ thisValor √© o valor que voc√™ quer que this tenha dentro da fun√ß√£o.
üîπ Os argumentos da fun√ß√£o s√£o passados separados por v√≠rgula.

Exemplo:
function saudacao(saudacaoInicial, pontuacao) {
    console.log(`${saudacaoInicial}, eu sou ${this.nome}${pontuacao}`);
}

const pessoa = { nome: "Renan" };

saudacao.call(pessoa, "Ol√°", "!");
// Sa√≠da: "Ol√°, eu sou Renan!"

2. apply
Sintaxe:
func.apply(thisValor, [arg1, arg2, ...]);
Funciona igual ao call, mas os argumentos s√£o passados em um array.

Exemplo:
saudacao.apply(pessoa, ["Oi", "!!"]);
// Sa√≠da: "Oi, eu sou Renan!!"

| M√©todo  | Passagem de argumentos     |
| ------- | -------------------------- |
| `call`  | Lista separada por v√≠rgula |
| `apply` | Array de argumentos        |

üí° Ambos s√£o √∫teis quando voc√™ quer reutilizar fun√ß√µes em diferentes objetos.

    ‚ö°‚ö° Obejtos ‚ö°‚ö°

üîπ O que s√£o?

Estruturas que representam entidades do mundo real.
Guardam propriedades (caracter√≠sticas) e m√©todos (a√ß√µes).

‚û°Ô∏è Exemplo:
const pessoa = {
  nome: "Renan",
  idade: 20,
  falar() {
    console.log("Oi, eu sou " + this.nome);
  }
};

üîπ Acessando propriedades
Ponto ‚Üí pessoa.nome
Colchetes ‚Üí pessoa["idade"]

üîπ Criando objetos
‚û°Ô∏è Literal:
const carro = { modelo: "Gol", ano: 2020 };

‚û°Ô∏è new Object():
const obj = new Object();
obj.nome = "Teste";

‚û°Ô∏è Factory Function:
function criarProduto(nome, preco) {
  return { nome, preco };
}

‚û°Ô∏è Classe (ES6):
class Produto {
  constructor(nome, preco) {
    this.nome = nome;
    this.preco = preco;
  }
}

üîπ Propriedades especiais
delete obj.propriedade ‚Üí remove uma chave.
Object.keys(obj) ‚Üí retorna array com as chaves.
Object.values(obj) ‚Üí retorna array com os valores.
Object.entries(obj) ‚Üí pares [chave, valor].

üîπ Percorrendo objeto
for (let chave in pessoa) {
  console.log(chave, pessoa[chave]);
}

üîπ JSON (JavaScript Object Notation)
√â s√≥ texto no formato de par nome/valor.
Usado para troca de dados entre sistemas.

üîπ Resum√£o
Objeto = cole√ß√£o de pares nome/valor.
Acesso por . ou [].
Criado via literal, fun√ß√£o, classe, ou new Object.
Pode ter m√©todos (this acessa propriedades).
Convers√£o para JSON ‚Üí JSON.stringify / JSON.parse.

------------------------------------------------------------------------------------------
.env
(master)
$ git pull origin master
$ git checkout master
$ git push origin master

up/down para subir container

vite -> weback (vai pegar tudo q vc escreveu e vai compilar)

estudar git e depois chamar o igor para upar essa pasta de estudo 
--------------------------------------------------------------------------------------------------

para mudar algo 
dar um cntc no texto e colar no search do vs code para achar

<> typescript -> preven√ß√£o de erro e sugestao de maneira mais facil 

view - do typescript
vue - do JavaScript (componente)

:deep vue  

SFC SCSS FEACTURES

$ git checkout -b feacture- 164-melhorias-cards 
cria uma nova tarefa para usar

$ git commmit 

$ git status

$ git log

$ git push origin feacture/164-melhorias-cards